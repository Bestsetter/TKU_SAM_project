<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TKU SAM â€” Breast Tumor Segmentation Demo</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #181818;
      color: #ccc;
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 24px 16px;
      gap: 20px;
    }
    h1 { font-size: 1.5rem; color: #eee; text-align: center; }
    p.subtitle { font-size: 0.9rem; color: #888; text-align: center; }

    #upload-area {
      border: 2px dashed #444;
      border-radius: 8px;
      padding: 20px 40px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s;
      width: 100%;
      max-width: 540px;
    }
    #upload-area:hover, #upload-area.dragover { border-color: #6af; }
    #upload-area input { display: none; }

    #canvas-wrap {
      position: relative;
      display: none;
    }
    canvas {
      display: block;
      cursor: crosshair;
      border: 1px solid #555;
      border-radius: 4px;
    }
    #canvas-wrap label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      text-align: center;
      margin-top: 6px;
    }

    .btn {
      padding: 10px 28px;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }
    #predict-btn { background: #3a7bd5; color: #fff; }
    #predict-btn:not(:disabled):hover { background: #2f67be; }
    #reset-btn { background: #444; color: #ccc; font-size: 0.85rem; padding: 8px 18px; }

    #bbox-info { font-size: 0.82rem; color: #6af; min-height: 1.2em; }

    #result-section { display: none; width: 100%; max-width: 900px; text-align: center; }
    #result-section h2 { color: #eee; margin-bottom: 12px; }
    #result-img { max-width: 100%; border-radius: 6px; border: 1px solid #444; }

    #classification-badge {
      display: inline-block;
      margin-bottom: 14px;
      padding: 8px 24px;
      border-radius: 999px;
      font-size: 1.1rem;
      font-weight: bold;
      letter-spacing: 0.03em;
    }
    .badge-benign    { background: #1a4d2e; color: #6fe88a; border: 1px solid #6fe88a; }
    .badge-malignant { background: #4d1a1a; color: #f77; border: 1px solid #f77; }
    .badge-na        { background: #333; color: #aaa; border: 1px solid #555; }
    #classification-detail { font-size: 0.82rem; color: #888; margin-bottom: 10px; }

    #status { font-size: 0.85rem; color: #fa8; min-height: 1.2em; }
  </style>
</head>
<body>
  <h1>ä¹³æˆ¿è…«ç˜¤åˆ‡å‰² Demo</h1>
  <p class="subtitle">ä¸Šå‚³è¶…éŸ³æ³¢åœ–ç‰‡ â†’ æ¡†é¸è…«ç˜¤ç¯„åœ â†’ é» Predict</p>

  <!-- Upload -->
  <div id="upload-area" onclick="document.getElementById('file-input').click()">
    <input type="file" id="file-input" accept="image/*" />
    <p>é»æ“Šæˆ–æ‹–æ›³åœ–ç‰‡è‡³æ­¤è™•</p>
    <p style="font-size:0.8rem;color:#666;margin-top:6px;">æ”¯æ´ PNG / JPG / BMP</p>
  </div>

  <!-- Canvas for bbox drawing (logic size 256x256, CSS display 512x512) -->
  <div id="canvas-wrap">
    <canvas id="canvas" width="256" height="256"
            style="width:512px;height:512px;"></canvas>
    <label>åœ¨è…«ç˜¤ä¸Šæ‹–æ›³ç•«å‡º Bounding Boxï¼ˆæ¡†ç·šç‚ºé»ƒè‰²ï¼‰</label>
  </div>

  <div id="bbox-info">å°šæœªç•«æ¡†</div>

  <!-- Optional ground truth mask upload -->
  <div id="mask-upload-area" style="display:none; border:1px dashed #555; border-radius:6px; padding:10px 24px; text-align:center; cursor:pointer; width:100%; max-width:512px;" onclick="document.getElementById('mask-input').click()">
    <input type="file" id="mask-input" accept="image/*" style="display:none;" />
    <span id="mask-label" style="font-size:0.85rem; color:#888;">ğŸ“‚ é¸æ“‡ Ground Truth Maskï¼ˆé¸ç”¨ï¼‰â€” å¯è¨ˆç®— Recall / Precision / Dice</span>
  </div>

  <div style="display:flex;gap:12px;align-items:center;">
    <button class="btn" id="reset-btn" style="display:none;" onclick="resetCanvas()">é‡æ–°æ¡†é¸</button>
    <button class="btn" id="predict-btn" disabled onclick="predict()">Predict</button>
  </div>

  <div id="status"></div>

  <!-- Result -->
  <div id="result-section">
    <h2>åˆ†å‰²çµæœ</h2>
    <div id="classification-badge" class="badge-na">â€”</div>
    <div id="classification-detail"></div>
    <img id="result-img" src="" alt="result" />
  </div>

  <script>
    const LOGIC = 256;     // model input space
    const DISPLAY = 512;   // CSS display px
    const SCALE = DISPLAY / LOGIC;  // 2

    const uploadArea = document.getElementById('upload-area');
    const fileInput  = document.getElementById('file-input');
    const canvasWrap = document.getElementById('canvas-wrap');
    const canvas     = document.getElementById('canvas');
    const ctx        = canvas.getContext('2d');
    const bboxInfo   = document.getElementById('bbox-info');
    const predictBtn = document.getElementById('predict-btn');
    const resetBtn   = document.getElementById('reset-btn');
    const status     = document.getElementById('status');
    const resultSec  = document.getElementById('result-section');
    const resultImg  = document.getElementById('result-img');
    const clsBadge   = document.getElementById('classification-badge');
    const clsDetail  = document.getElementById('classification-detail');

    let uploadedFile = null;
    let maskFile     = null;
    let baseImage = null;   // ImageBitmap loaded into canvas
    let bbox = null;        // {x1,y1,x2,y2} in logic (256) space
    let drawing = false;
    let startX, startY;

    const maskInput      = document.getElementById('mask-input');
    const maskLabel      = document.getElementById('mask-label');
    const maskUploadArea = document.getElementById('mask-upload-area');

    maskInput.addEventListener('change', () => {
      if (maskInput.files[0]) {
        maskFile = maskInput.files[0];
        maskLabel.textContent = `âœ… Mask å·²é¸æ“‡ï¼š${maskFile.name}`;
        maskLabel.style.color = '#6f6';
      }
    });

    // Drag-and-drop
    uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.classList.add('dragover'); });
    uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
    uploadArea.addEventListener('drop', e => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      handleFile(e.dataTransfer.files[0]);
    });
    fileInput.addEventListener('change', () => handleFile(fileInput.files[0]));

    function handleFile(file) {
      if (!file || !file.type.startsWith('image/')) return;
      uploadedFile = file;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = async () => {
        baseImage = await createImageBitmap(img);
        resetCanvas();
        uploadArea.style.display = 'none';
        canvasWrap.style.display = 'block';
        resetBtn.style.display = 'inline-block';
        maskUploadArea.style.display = 'block';
      };
      img.src = url;
    }

    function drawBase() {
      ctx.clearRect(0, 0, LOGIC, LOGIC);
      ctx.drawImage(baseImage, 0, 0, LOGIC, LOGIC);
    }

    function resetCanvas() {
      bbox = null;
      bboxInfo.textContent = 'å°šæœªç•«æ¡†';
      predictBtn.disabled = true;
      resultSec.style.display = 'none';
      status.textContent = '';
      if (baseImage) drawBase();
    }

    // Convert CSS mouse coords â†’ logic (256) space
    function getLogicCoords(e) {
      const rect = canvas.getBoundingClientRect();
      const cssX = e.clientX - rect.left;
      const cssY = e.clientY - rect.top;
      return {
        x: Math.round(cssX / SCALE),
        y: Math.round(cssY / SCALE),
      };
    }

    canvas.addEventListener('mousedown', e => {
      const p = getLogicCoords(e);
      startX = p.x; startY = p.y;
      drawing = true;
      bbox = null;
      predictBtn.disabled = true;
    });

    canvas.addEventListener('mousemove', e => {
      if (!drawing) return;
      const p = getLogicCoords(e);
      drawBase();
      // preview rect in logic coords (canvas 1px = 1 logic unit)
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 1;
      ctx.strokeRect(startX, startY, p.x - startX, p.y - startY);
    });

    canvas.addEventListener('mouseup', e => {
      if (!drawing) return;
      drawing = false;
      const p = getLogicCoords(e);
      const x1 = Math.min(startX, p.x);
      const y1 = Math.min(startY, p.y);
      const x2 = Math.max(startX, p.x);
      const y2 = Math.max(startY, p.y);
      if (x2 - x1 < 4 || y2 - y1 < 4) {
        bboxInfo.textContent = 'æ¡†å¤ªå°ï¼Œè«‹é‡æ–°æ¡†é¸';
        return;
      }
      bbox = {x1, y1, x2, y2};
      drawBase();
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 1;
      ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
      bboxInfo.textContent = `Bbox (256px ç©ºé–“): [${x1}, ${y1}, ${x2}, ${y2}]`;
      predictBtn.disabled = false;
    });

    // Touch support (mobile)
    function touchToMouse(e, type) {
      e.preventDefault();
      const touch = e.touches[0] || e.changedTouches[0];
      canvas.dispatchEvent(new MouseEvent(type, {
        clientX: touch.clientX, clientY: touch.clientY
      }));
    }
    canvas.addEventListener('touchstart',  e => touchToMouse(e, 'mousedown'));
    canvas.addEventListener('touchmove',   e => touchToMouse(e, 'mousemove'));
    canvas.addEventListener('touchend',    e => touchToMouse(e, 'mouseup'));

    async function predict() {
      if (!uploadedFile || !bbox) return;
      predictBtn.disabled = true;
      status.textContent = 'æ¨è«–ä¸­ï¼Œè«‹ç¨å€™â€¦ï¼ˆé¦–æ¬¡ç´„éœ€ 10-30 ç§’ï¼‰';
      resultSec.style.display = 'none';

      const bboxArr = [bbox.x1, bbox.y1, bbox.x2, bbox.y2];
      const formData = new FormData();
      formData.append('image', uploadedFile);
      formData.append('bbox', JSON.stringify(bboxArr));
      if (maskFile) formData.append('mask', maskFile);

      try {
        const resp = await fetch('/predict', { method: 'POST', body: formData });
        if (!resp.ok) {
          const txt = await resp.text();
          status.textContent = `éŒ¯èª¤ï¼š${resp.status} â€” ${txt}`;
          predictBtn.disabled = false;
          return;
        }
        const data = await resp.json();

        // Show segmentation image
        resultImg.src = `data:image/png;base64,${data.image}`;

        // Show classification badge
        if (data.label === 'Benign') {
          clsBadge.textContent = 'è‰¯æ€§ Benign';
          clsBadge.className = 'badge-benign';
        } else if (data.label === 'Malignant') {
          clsBadge.textContent = 'æƒ¡æ€§ Malignant';
          clsBadge.className = 'badge-malignant';
        } else {
          clsBadge.textContent = 'â€”';
          clsBadge.className = 'badge-na';
        }
        clsDetail.textContent =
          `Benign: ${(data.prob_benign * 100).toFixed(1)}%ã€€Malignant: ${(data.prob_malignant * 100).toFixed(1)}%`;

        resultSec.style.display = 'block';
        status.textContent = 'æ¨è«–å®Œæˆï¼';
      } catch (err) {
        status.textContent = `ç¶²è·¯éŒ¯èª¤ï¼š${err}`;
      }
      predictBtn.disabled = false;
    }
  </script>
</body>
</html>
